name: Deploy Applications to EKS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
        default: 'dev'
      deployment_method:
        description: 'Deployment method'
        required: true
        type: choice
        options:
          - argocd
          - helm
        default: 'argocd'
      services:
        description: 'Services to deploy (comma-separated or "all")'
        required: true
        default: 'all'
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: false
        type: string
        default: 'dev'
      deployment_method:
        description: 'Deployment method'
        required: false
        type: string
        default: 'argocd'
      services:
        description: 'Services to deploy (comma-separated or "all")'
        required: false
        type: string
        default: 'all'

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: eks-1

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set ECR Account ID
        id: aws-account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "ECR Account ID: $ACCOUNT_ID"

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.0'

      - name: Check EKS Cluster Exists
        run: |
          echo "Checking if EKS cluster '${{ env.CLUSTER_NAME }}' exists..."
          if aws eks describe-cluster --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }} > /dev/null 2>&1; then
            echo "Cluster found: ${{ env.CLUSTER_NAME }}"
          else
            echo "ERROR: Cluster '${{ env.CLUSTER_NAME }}' not found!"
            echo ""
            echo "Available clusters:"
            aws eks list-clusters --region ${{ env.AWS_REGION }}
            echo ""
            echo "Please create the EKS cluster first by running:"
            echo "  gh workflow run eks-terraform.yml -f action=apply -f environment=dev"
            exit 1
          fi

      - name: Configure kubectl
        run: |
          echo "Configuring kubectl for cluster: ${{ env.CLUSTER_NAME }}"
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

          echo "Cluster info:"
          kubectl cluster-info

          echo ""
          echo "Node status:"
          kubectl get nodes

      - name: Create namespace
        run: |
          kubectl create namespace ${{ inputs.environment }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create ECR Secret
        run: |
          echo "Creating ECR secret for account ${{ steps.aws-account.outputs.account_id }}..."
          kubectl create secret docker-registry ecr-secret \
            --docker-server=${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com \
            --docker-username=AWS \
            --docker-password=$(aws ecr get-login-password --region ${{ env.AWS_REGION }}) \
            --namespace=${{ inputs.environment }} \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "ECR secret created successfully"

      - name: Check ALB Controller Status
        id: alb-check
        continue-on-error: true
        run: |
          echo "Checking ALB Controller status..."

          # Check if ALB controller is running
          if kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --no-headers 2>/dev/null | grep -q "Running"; then
            echo "ALB Controller is running"
            echo "alb_ready=true" >> $GITHUB_OUTPUT
          else
            echo "ALB Controller is NOT running or not installed"
            echo "alb_ready=false" >> $GITHUB_OUTPUT
            echo ""
            echo "ALB Controller pods:"
            kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller 2>/dev/null || echo "No ALB controller pods found"
          fi

          # Check ingress class
          echo ""
          echo "Ingress classes:"
          kubectl get ingressclass 2>/dev/null || echo "No ingress classes found"

      - name: Deploy with ArgoCD
        if: inputs.deployment_method == 'argocd' || inputs.deployment_method == ''
        run: |
          echo "=== Deploying with ArgoCD (GitOps) ==="

          # Check if ArgoCD is installed
          if ! kubectl get namespace argocd &>/dev/null; then
            echo "Installing ArgoCD..."
            kubectl create namespace argocd
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

            echo "Waiting for ArgoCD to be ready..."
            kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd
          else
            echo "ArgoCD already installed"
          fi

          # Update image tags in values-eks.yaml files with actual AWS account ID
          echo "Updating Helm values with AWS Account ID..."
          for service in api-gateway user-management-service exercises-service scores-service frontend; do
            VALUES_FILE="helm/${service}/values-eks.yaml"
            if [ -f "$VALUES_FILE" ]; then
              sed -i "s/\${AWS_ACCOUNT_ID}/${{ steps.aws-account.outputs.account_id }}/g" "$VALUES_FILE"
              echo "Updated: $VALUES_FILE"
            fi
          done

          # Apply ArgoCD applications
          echo "Applying ArgoCD applications..."
          kubectl apply -f argocd/argocd-applications.yaml

          echo ""
          echo "=== ArgoCD Applications Status ==="
          sleep 10
          kubectl get applications -n argocd

          echo ""
          echo "ArgoCD will now sync applications automatically."
          echo "Access ArgoCD UI to monitor deployment progress."

      - name: Deploy with Helm (Direct)
        if: inputs.deployment_method == 'helm'
        run: |
          echo "=== Deploying with Helm (Direct) ==="

          # Cleanup stuck Helm releases
          echo "Checking for stuck Helm releases..."
          SERVICES=("api-gateway" "user-management-service" "exercises-service" "scores-service" "frontend")

          for service in "${SERVICES[@]}"; do
            if helm status "$service" -n ${{ inputs.environment }} 2>/dev/null | grep -q "STATUS: pending"; then
              echo "Found stuck release: $service. Cleaning up..."
              helm uninstall "$service" -n ${{ inputs.environment }} --wait || true
            elif helm status "$service" -n ${{ inputs.environment }} 2>/dev/null | grep -q "STATUS: failed"; then
              echo "Found failed release: $service. Cleaning up..."
              helm uninstall "$service" -n ${{ inputs.environment }} --wait || true
            fi
          done

          echo "Cleanup complete"

          # Set common Helm values
          ECR_REPO="${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/nt114-devsecops"

          # Deploy services
          deploy_service() {
            local service=$1
            local port=$2

            echo ""
            echo "Deploying $service..."

            if helm upgrade --install "$service" "./helm/$service" \
              --namespace ${{ inputs.environment }} \
              --set image.repository="${ECR_REPO}/$service" \
              --set image.tag=latest \
              --set image.pullPolicy=Always \
              -f "./helm/$service/values-eks.yaml" \
              --wait --timeout 10m; then
              echo "$service deployed successfully"
            else
              echo "$service deployment failed!"
              echo ""
              echo "=== POD STATUS ==="
              kubectl get pods -l app.kubernetes.io/name=$service -n ${{ inputs.environment }} || true
              echo ""
              echo "=== POD DESCRIBE ==="
              kubectl describe pod -l app.kubernetes.io/name=$service -n ${{ inputs.environment }} || true
              echo ""
              echo "=== POD LOGS ==="
              kubectl logs -l app.kubernetes.io/name=$service -n ${{ inputs.environment }} --tail=100 || true
              return 1
            fi
          }

          # Deploy all services
          DEPLOY_FAILED=false

          if [[ "${{ inputs.services }}" == "all" ]] || [[ "${{ inputs.services }}" == *"user-management-service"* ]]; then
            deploy_service "user-management-service" 5001 || DEPLOY_FAILED=true
          fi

          if [[ "${{ inputs.services }}" == "all" ]] || [[ "${{ inputs.services }}" == *"exercises-service"* ]]; then
            deploy_service "exercises-service" 5002 || DEPLOY_FAILED=true
          fi

          if [[ "${{ inputs.services }}" == "all" ]] || [[ "${{ inputs.services }}" == *"scores-service"* ]]; then
            deploy_service "scores-service" 5003 || DEPLOY_FAILED=true
          fi

          if [[ "${{ inputs.services }}" == "all" ]] || [[ "${{ inputs.services }}" == *"api-gateway"* ]]; then
            deploy_service "api-gateway" 8000 || DEPLOY_FAILED=true
          fi

          if [[ "${{ inputs.services }}" == "all" ]] || [[ "${{ inputs.services }}" == *"frontend"* ]]; then
            deploy_service "frontend" 80 || DEPLOY_FAILED=true
          fi

          if [ "$DEPLOY_FAILED" = true ]; then
            echo ""
            echo "One or more deployments failed!"
            exit 1
          fi

          echo ""
          echo "All services deployed successfully!"

      - name: Get Deployment Status
        run: |
          echo "### Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Method:** ${{ inputs.deployment_method }}" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster:** ${{ env.CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "#### Deployed Services" >> $GITHUB_STEP_SUMMARY
          kubectl get deployments -n ${{ inputs.environment }} >> $GITHUB_STEP_SUMMARY || echo "No deployments found" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "#### Service Endpoints" >> $GITHUB_STEP_SUMMARY
          kubectl get services -n ${{ inputs.environment }} >> $GITHUB_STEP_SUMMARY || echo "No services found" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "#### Ingress URLs" >> $GITHUB_STEP_SUMMARY
          kubectl get ingress -n ${{ inputs.environment }} >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "No ingress found" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Pod Status" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ inputs.environment }} -o wide >> $GITHUB_STEP_SUMMARY || true

      - name: Get ArgoCD Access Info
        if: inputs.deployment_method == 'argocd' || inputs.deployment_method == ''
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### ArgoCD Access" >> $GITHUB_STEP_SUMMARY

          # Get ArgoCD password
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" 2>/dev/null | base64 -d) || ARGOCD_PASSWORD="<not available>"

          # Get ArgoCD URL
          ARGOCD_URL=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null) || ARGOCD_URL="<pending>"

          echo "- **ArgoCD URL:** https://${ARGOCD_URL}" >> $GITHUB_STEP_SUMMARY
          echo "- **Username:** admin" >> $GITHUB_STEP_SUMMARY
          echo "- **Password:** See workflow output (not shown in summary for security)" >> $GITHUB_STEP_SUMMARY

          echo ""
          echo "=== ArgoCD Access Information ==="
          echo "URL: https://${ARGOCD_URL}"
          echo "Username: admin"
          echo "Password: ${ARGOCD_PASSWORD}"

          echo ""
          echo "=== ArgoCD Application Status ==="
          kubectl get applications -n argocd

  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success()
    continue-on-error: true

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      - name: Wait for Pods Ready
        run: |
          echo "Waiting for pods to be ready..."

          # Wait up to 10 minutes for pods
          for i in {1..60}; do
            PENDING_PODS=$(kubectl get pods -n ${{ inputs.environment }} --no-headers 2>/dev/null | grep -v "Running\|Completed" | wc -l)

            if [ "$PENDING_PODS" -eq 0 ]; then
              echo "All pods are running!"
              break
            fi

            echo "Waiting for $PENDING_PODS pods to be ready... (attempt $i/60)"
            sleep 10
          done

          echo ""
          echo "=== Final Pod Status ==="
          kubectl get pods -n ${{ inputs.environment }} -o wide

          echo ""
          echo "=== Deployment Status ==="
          kubectl get deployments -n ${{ inputs.environment }}

      - name: Run Health Checks
        run: |
          echo "### Health Check Results" >> $GITHUB_STEP_SUMMARY

          # Get API Gateway service endpoint
          API_GATEWAY_SVC=$(kubectl get service api-gateway -n ${{ inputs.environment }} -o jsonpath='{.spec.clusterIP}' 2>/dev/null) || true

          if [ ! -z "$API_GATEWAY_SVC" ]; then
            echo "Testing API Gateway health endpoint..."

            # Port-forward and test
            kubectl port-forward svc/api-gateway -n ${{ inputs.environment }} 8080:8080 &
            PF_PID=$!
            sleep 5

            if curl -sf http://localhost:8080/health; then
              echo "API Gateway health check PASSED" >> $GITHUB_STEP_SUMMARY
            else
              echo "API Gateway health check FAILED or not reachable" >> $GITHUB_STEP_SUMMARY
            fi

            kill $PF_PID 2>/dev/null || true
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Events (Last 20)" >> $GITHUB_STEP_SUMMARY
          kubectl get events -n ${{ inputs.environment }} --sort-by='.lastTimestamp' | tail -20 >> $GITHUB_STEP_SUMMARY || echo "No events" >> $GITHUB_STEP_SUMMARY
